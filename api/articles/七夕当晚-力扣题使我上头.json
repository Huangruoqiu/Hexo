{"title":"七夕当晚，力扣题使我上头","slug":"七夕当晚-力扣题使我上头","date":"2021-08-15T09:36:27.000Z","updated":"2021-08-15T09:36:27.000Z","comments":true,"path":"api/articles/七夕当晚-力扣题使我上头.json","excerpt":null,"cover":"https://cdn.jsdelivr.net/gh/huangruoqiu/HexoPicture/cover/%E4%B8%83%E5%A4%95%E5%BD%93%E6%99%9A-%E5%8A%9B%E6%89%A3%E9%A2%98%E4%BD%BF%E6%88%91%E4%B8%8A%E5%A4%B4.PNG","covers":["https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png","https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png","https://pic.leetcode-cn.com/1629028967-keaany-file_1629028967348"],"content":"<p>七夕当晚，零点一过，我照常登录力扣，准备早点打卡睡觉。结果没想到，因为一点小小的失误花了近一个小时，被迫熬夜呜呜呜呜。好在这道题很经典，同时涉及深度优先算法、记忆化搜索、数组原型的fill函数，想了想还是贴上来丢人o(≧口≦)o</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><hr>\n<p>链接在这：<a href=\"https://leetcode-cn.com/problems/out-of-boundary-paths/\">576. 出界的路径数</a>，题目描述如下。</p>\n<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>\n<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png\"></p>\n<blockquote>\n<p><strong>输入：</strong> m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0</p>\n<p><strong>输出：</strong> 6</p>\n</blockquote>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png\"></p>\n<blockquote>\n<p><strong>输入：</strong> m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1</p>\n<p><strong>输出：</strong> 12</p>\n</blockquote>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= m, n &lt;= 50</code></li>\n<li><code>0 &lt;= maxMove &lt;= 50</code></li>\n<li><code>0 &lt;= startRow &lt; m</code></li>\n<li><code>0 &lt;= startColumn &lt; n</code></li>\n</ul>\n<h2 id=\"心路历程\"><a href=\"#心路历程\" class=\"headerlink\" title=\"心路历程\"></a>心路历程</h2><hr>\n<h3 id=\"Easy\"><a href=\"#Easy\" class=\"headerlink\" title=\"Easy\"></a><em><strong>Easy</strong></em></h3><p>看到题的三又四分之一分钟后，我想到了解法，不过这次，我决定先倒一杯凉白开。</p>\n<p>这不就是个简单的DFS嘛，从某个节点开始，一步一步走，出界就次数+1，再回溯到上一步。如果在限定的次数内还没有出界，则说明路径不符合要求。套路和这题 <a href=\"https://leetcode-cn.com/problems/chuan-di-xin-xi/\">LCP 07. 传递信息</a> 差不多。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">m</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">n</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">maxMove</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startRow</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startColumn</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findPaths = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n, maxMove, startRow, startColumn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\">(<span class=\"params\">row, col, step</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; <span class=\"number\">0</span> || col &lt; <span class=\"number\">0</span> || row &gt;= m || col &gt;= n) &#123;</span><br><span class=\"line\">            result++</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> nextArr = [[row + <span class=\"number\">1</span>, col], [row - <span class=\"number\">1</span>, col], [row, col - <span class=\"number\">1</span>], [row, col + <span class=\"number\">1</span>]]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> next <span class=\"keyword\">of</span> nextArr) &#123;</span><br><span class=\"line\">            dfs(next[<span class=\"number\">0</span>], next[<span class=\"number\">1</span>], step - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(startRow, startColumn, maxMove)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>啪就提交了，很快啊，然后返回超时(╬▔皿▔)╯</p>\n<p><img src=\"https://pic.leetcode-cn.com/1629028967-keaany-file_1629028967348\"></p>\n<h3 id=\"有点意思\"><a href=\"#有点意思\" class=\"headerlink\" title=\"有点意思\"></a><em><strong>有点意思</strong></em></h3><p>我大意了啊，没有考虑时间复杂度。事实上很容易发现递归过程中会多次经过相同的位置，那假设记录下每个位置在指定步数时的可越界次数，那是不是下次同样步数走到该位置上，就可以直接返回结果。</p>\n<p>用一个三维数组保存某坐标某步数时的结果，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">m</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">n</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">maxMove</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startRow</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startColumn</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findPaths = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n, maxMove, startRow, startColumn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(maxMove + <span class=\"number\">1</span>).fill(-<span class=\"number\">1</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> MOD = <span class=\"number\">1000000007</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\">(<span class=\"params\">row, col, step</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; <span class=\"number\">0</span> || col &lt; <span class=\"number\">0</span> || row &gt;= m || col &gt;= n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result[row][col][step] !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result[row][col][step]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> nextArr = [[row + <span class=\"number\">1</span>, col], [row - <span class=\"number\">1</span>, col], [row, col - <span class=\"number\">1</span>], [row, col + <span class=\"number\">1</span>]]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> next <span class=\"keyword\">of</span> nextArr) &#123;</span><br><span class=\"line\">            res += dfs(next[<span class=\"number\">0</span>], next[<span class=\"number\">1</span>], step - <span class=\"number\">1</span>)</span><br><span class=\"line\">            res %= MOD</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result[row][col][step] = res</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(startRow, startColumn, maxMove)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我喝了口凉白开，边想着终于可睡觉了，边按下测试按钮，结果却是答案错误(⊙ˍ⊙)？</p>\n<h3 id=\"拨云见日\"><a href=\"#拨云见日\" class=\"headerlink\" title=\"拨云见日\"></a><em><strong>拨云见日</strong></em></h3><p>为啥不对呢，逻辑明明是正确的，除非数组缓存数据有错。于是增加打印，发现数组并没有按照预期存值。当修改result[x][y][z]的值时，所有Z坐标为z的点，值都发生了变化，并不是期望中的只改变了某个点的值。</p>\n<p>举个简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>).fill(-<span class=\"number\">1</span>))) <span class=\"comment\">// result = [[[-1, -1], [-1, -1]], [[-1, -1], [-1, -1]]]</span></span><br><span class=\"line\">result[<span class=\"number\">0</span>][<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">2</span> <span class=\"comment\">// result = [[[-1, 2], [-1, 2]], [[-1, 2], [-1, 2]]]</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：fill函数如果传入的是引用数据类型，那么每一个元素都是对这个对象的引用，所以会出现改一个，所有值都改变的情况。上面代码的缓存数据做如下修改：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- let result = new Array(m).fill(new Array(n).fill(new Array(maxMove + 1).fill(-1)))</span></span><br><span class=\"line\"><span class=\"addition\">+ let result = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0).map(() =&gt; new Array(maxMove + 1).fill(-1)))</span></span><br></pre></td></tr></table></figure>\n\n<p>果不其然AC了，时间超过96%的记录，内存只超过25%的提交记录。</p>\n<h2 id=\"附加题\"><a href=\"#附加题\" class=\"headerlink\" title=\"附加题\"></a>附加题</h2><hr>\n<ol>\n<li><p><a href=\"https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/\">787. K 站中转内最便宜的航班</a>。节点数量最大100个，可使用类似DFS+记忆搜索解法。</p>\n</li>\n<li><p><a href=\"https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/\">1928. 规定时间内到达终点的最小花费</a>。节点数量最大1000个，采用DFS解法时空复杂度太高，会超出时间限制，需使用更高级的动态规划。</p>\n</li>\n</ol>\n","more":"<p>七夕当晚，零点一过，我照常登录力扣，准备早点打卡睡觉。结果没想到，因为一点小小的失误花了近一个小时，被迫熬夜呜呜呜呜。好在这道题很经典，同时涉及深度优先算法、记忆化搜索、数组原型的fill函数，想了想还是贴上来丢人o(≧口≦)o</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><hr>\n<p>链接在这：<a href=\"https://leetcode-cn.com/problems/out-of-boundary-paths/\">576. 出界的路径数</a>，题目描述如下。</p>\n<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>\n<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png\"></p>\n<blockquote>\n<p><strong>输入：</strong> m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0</p>\n<p><strong>输出：</strong> 6</p>\n</blockquote>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png\"></p>\n<blockquote>\n<p><strong>输入：</strong> m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1</p>\n<p><strong>输出：</strong> 12</p>\n</blockquote>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= m, n &lt;= 50</code></li>\n<li><code>0 &lt;= maxMove &lt;= 50</code></li>\n<li><code>0 &lt;= startRow &lt; m</code></li>\n<li><code>0 &lt;= startColumn &lt; n</code></li>\n</ul>\n<h2 id=\"心路历程\"><a href=\"#心路历程\" class=\"headerlink\" title=\"心路历程\"></a>心路历程</h2><hr>\n<h3 id=\"Easy\"><a href=\"#Easy\" class=\"headerlink\" title=\"Easy\"></a><em><strong>Easy</strong></em></h3><p>看到题的三又四分之一分钟后，我想到了解法，不过这次，我决定先倒一杯凉白开。</p>\n<p>这不就是个简单的DFS嘛，从某个节点开始，一步一步走，出界就次数+1，再回溯到上一步。如果在限定的次数内还没有出界，则说明路径不符合要求。套路和这题 <a href=\"https://leetcode-cn.com/problems/chuan-di-xin-xi/\">LCP 07. 传递信息</a> 差不多。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">m</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">n</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">maxMove</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startRow</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startColumn</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findPaths = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n, maxMove, startRow, startColumn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\">(<span class=\"params\">row, col, step</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; <span class=\"number\">0</span> || col &lt; <span class=\"number\">0</span> || row &gt;= m || col &gt;= n) &#123;</span><br><span class=\"line\">            result++</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> nextArr = [[row + <span class=\"number\">1</span>, col], [row - <span class=\"number\">1</span>, col], [row, col - <span class=\"number\">1</span>], [row, col + <span class=\"number\">1</span>]]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> next <span class=\"keyword\">of</span> nextArr) &#123;</span><br><span class=\"line\">            dfs(next[<span class=\"number\">0</span>], next[<span class=\"number\">1</span>], step - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(startRow, startColumn, maxMove)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>啪就提交了，很快啊，然后返回超时(╬▔皿▔)╯</p>\n<p><img src=\"https://pic.leetcode-cn.com/1629028967-keaany-file_1629028967348\"></p>\n<h3 id=\"有点意思\"><a href=\"#有点意思\" class=\"headerlink\" title=\"有点意思\"></a><em><strong>有点意思</strong></em></h3><p>我大意了啊，没有考虑时间复杂度。事实上很容易发现递归过程中会多次经过相同的位置，那假设记录下每个位置在指定步数时的可越界次数，那是不是下次同样步数走到该位置上，就可以直接返回结果。</p>\n<p>用一个三维数组保存某坐标某步数时的结果，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">m</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">n</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">maxMove</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startRow</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">startColumn</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findPaths = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m, n, maxMove, startRow, startColumn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(maxMove + <span class=\"number\">1</span>).fill(-<span class=\"number\">1</span>)))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> MOD = <span class=\"number\">1000000007</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\">(<span class=\"params\">row, col, step</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; <span class=\"number\">0</span> || col &lt; <span class=\"number\">0</span> || row &gt;= m || col &gt;= n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result[row][col][step] !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result[row][col][step]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> nextArr = [[row + <span class=\"number\">1</span>, col], [row - <span class=\"number\">1</span>, col], [row, col - <span class=\"number\">1</span>], [row, col + <span class=\"number\">1</span>]]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> next <span class=\"keyword\">of</span> nextArr) &#123;</span><br><span class=\"line\">            res += dfs(next[<span class=\"number\">0</span>], next[<span class=\"number\">1</span>], step - <span class=\"number\">1</span>)</span><br><span class=\"line\">            res %= MOD</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result[row][col][step] = res</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(startRow, startColumn, maxMove)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我喝了口凉白开，边想着终于可睡觉了，边按下测试按钮，结果却是答案错误(⊙ˍ⊙)？</p>\n<h3 id=\"拨云见日\"><a href=\"#拨云见日\" class=\"headerlink\" title=\"拨云见日\"></a><em><strong>拨云见日</strong></em></h3><p>为啥不对呢，逻辑明明是正确的，除非数组缓存数据有错。于是增加打印，发现数组并没有按照预期存值。当修改result[x][y][z]的值时，所有Z坐标为z的点，值都发生了变化，并不是期望中的只改变了某个点的值。</p>\n<p>举个简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>).fill(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>).fill(-<span class=\"number\">1</span>))) <span class=\"comment\">// result = [[[-1, -1], [-1, -1]], [[-1, -1], [-1, -1]]]</span></span><br><span class=\"line\">result[<span class=\"number\">0</span>][<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">2</span> <span class=\"comment\">// result = [[[-1, 2], [-1, 2]], [[-1, 2], [-1, 2]]]</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：fill函数如果传入的是引用数据类型，那么每一个元素都是对这个对象的引用，所以会出现改一个，所有值都改变的情况。上面代码的缓存数据做如下修改：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- let result = new Array(m).fill(new Array(n).fill(new Array(maxMove + 1).fill(-1)))</span></span><br><span class=\"line\"><span class=\"addition\">+ let result = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0).map(() =&gt; new Array(maxMove + 1).fill(-1)))</span></span><br></pre></td></tr></table></figure>\n\n<p>果不其然AC了，时间超过96%的记录，内存只超过25%的提交记录。</p>\n<h2 id=\"附加题\"><a href=\"#附加题\" class=\"headerlink\" title=\"附加题\"></a>附加题</h2><hr>\n<ol>\n<li><p><a href=\"https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/\">787. K 站中转内最便宜的航班</a>。节点数量最大100个，可使用类似DFS+记忆搜索解法。</p>\n</li>\n<li><p><a href=\"https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/\">1928. 规定时间内到达终点的最小花费</a>。节点数量最大1000个，采用DFS解法时空复杂度太高，会超出时间限制，需使用更高级的动态规划。</p>\n</li>\n</ol>\n","categories":[],"tags":[{"name":"JS","path":"api/tags/JS.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"力扣","path":"api/tags/力扣.json"}]}